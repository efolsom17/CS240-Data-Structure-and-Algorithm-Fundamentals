---
title: "Algorithms Assignment 1"
author: "Eric Folsom"
format: html
---

```{python, setup_py}
#| echo: false
#| output: false

# Setup Chunk for python, loading the required libraries
import numpy as np
import pandas as pd
```


```{r, setup_r}
#| echo: false
#| output: false

#Setup Chunk for R and Reticulate so that I can use ggplot if I ever have to graph stuff.
#This will most likely be useful for a later assignment.
library(reticulate)
library(tidyverse)
```

### Problem 1

For this problem we are writing psuedocode for an itterative binary search algorithm that works over an array.

To design an alogorithm to perform this task, we would implement something similar to the following:

* Assume we have an ordered array $X=\{x_0,x_1,\ldots,x_n\}$, where $x_i \leq x_{i+1}$, where $i=1,2,3,\ldots,n$. 

* We will define the value or object that we are looking for $y$. Also assume that $y\in X$
   
1. Find the largest index in the array, $n$.
   - Define the largest index ($x_n$).
   - Define the beginning (first) index to be the smallest ($x_0$).
2. Find the middle index $\frac{n}{2}$ (round to the nearest integer if $n$ is odd).
3. Inspect the value of the middle index $x_{\frac{n}{2}}$.
   i) If the value of $x_{\frac{n}{2}}$ equals $y$, stop because we have found the index of $y$
   ii) If the value of $y< x_{\frac{n}{2}}$.
    a. Redefine $x_n=x_{\frac{n}{2}}$.
    b. Pick a new $x_{\frac{n}{2}}$ using the same process as step 2. 
    c. Go to step 3.
   iii) If the value of $y > x_{\frac{n}{2}}$.
    a. Redefine $x_0=x_{\frac{n}{2}}$
    b. Pick a new $x_{\frac{n}{2}}$ using the same process as step 2.
    c. Go to step 3.

For each step in the algorithm, we are dividing the array in half, searching the middle index of the array, and then redefining the area in the array that we have to search. We do this until we have either found the index of the item, or we have exhausted all the possible indicies of the array to search, in which case we can conclude that the item does is not an element of the array.

### Problem 2

For this problem we have to write in code a binary search algorithm. For this I will be using Python.

```{python, binary search function}
#| echo: true 

def binary_search(item, data, oper = False, diag = False):

   # item: item in the data that we are interested in finding
   # data: list or array of data with items we are interested in finding, assumes
   #       ordered integer data.
   # oper: Logical T or F. Choose weather to include the number of operations. 
   #        Default: False.
   # diag: T or F. Choose to see the inner workings of the algorithm.
   #        Default: False.

   # Begin by defining some variables for keeping track of x0 and xn
   # as well as keeping track of the number of operations

   x0 = 0 #defining the index of first element of the array
   xn = len(data)-1 #defining the index of the last element of the array
   operations = 0 #creating a varaible to count the number of operations the 

   # Beginning the actual function
   while x0 <= xn: #while we are searching valid indicies of our array
      operations = operations + 1 #count one operation
      mid = (xn + x0) // 2 #pick the middle index of the array (floor operation)
      search = data[mid] # Value of the middle index (the one we are searching in)

      #Diagnostics/Inner workings
      #I had to use this a few times to resolve edge cases
      if diag == True:
        print("Target: ", item,
          '\nLowest Index: ', 
         x0,"\nHigh Index: ",xn,
         "\nIndex we are searching is: ",mid,
          " Value: ",search) 
      
      #if the item we are searching for is the same as the value of the array
      if search == item: 
         #if you want to see the number of operations
         if oper == True: 
            #return the index of the item and the number of
            #  operations it took to find the item
            print(f"Item {item} is located at index {mid}.\nThis took {operations} operations.")
            return item, mid, operations 
         else:
            #return the position of the item
            print(f"Item {item} is located at index {mid}.") 
            return item, mid, operations 

      # if our guess is too low
      elif search < item:
          #update the low index position to be the middle guess. 
          # Adding 1 so we don't recheck the same index twice
         x0 = mid + 1
         #diagnostics
         if diag == True:
           print('Search was too low') #debugging

      # if our guess is too high
      elif search > item: 
         # update the high position to be the middle guess. 
         # Subtracting 1 so we don't check the same index
         # twice, as that would be slow.
         xn = mid - 1 
         #diagnostics:
         if diag == True:
            print("Search was too high") #debugging

   # if we can't find the item in the array.
   return print("Item Not Found\nThis took ", operations, ' operations.')
```


### Problem 3 

For this problem we are given an attached file `numbers.txt` and we must use the algorithm that we wrote in problem 2 to answer the following question:

To begin we must load the `numbers.txt` file. 

```{python, loading data}
#| echo: true
#| output: false

## Importing the numbers data using the Pandas library as a dataframe

numbers = pd.read_csv("C:\\Users\\ericf\\OneDrive\\Desktop\\WCC\\CS240 Data Structure and Algorithm Fundamentals\\Assignments\\Algorithms Assignment 1\\Data\\numbers.txt",
header=None,
sep='\t'
)

## Converting Numbers to an array using Numpy ##
numbers = numbers.to_numpy()
# now back to base python for ease of use with the algorithm I just wrote:
numbers = numbers.tolist()
# fixing some jankiness with importing the data 
# so that all the elements of the list are integers
# instead of being lists of length 1, thanks ChatGPT.
con_numbers = [num[0] for num in numbers]
numbers = con_numbers
```

#### a. What is the position of 51216352 in the array? How many operations did it take to find?

We can find the position of 51216352 using the following code:

```{python, 3a}
#| echo: true

binary_search(51216352, numbers, oper=True)
```

#### b. What is the position of 198313119 in the array? How many operations did it take to find?

We can find the position of 198313119 using the following code:

```{python, 3b}
#| echo: true

binary_search(198313119, numbers, oper=True)
```


#### c. What is the position of 196614208 in the array? How many operations did it take to find?

We can find the position of 196614208 using the following code:

```{python, 3c}
#| echo: true

binary_search(196614208,numbers, oper=True)

```

#### d. What is the worst case time complexity? Evaluate line by line, create a time complexity function and then define its Big O value.


Assume we have an ordered array $X=\{x_0,x_1,\ldots,x_n\}$, where $x_i \leq x_{i+1}$, where $i=1,2,3,\ldots,n$. To figure out what the worst case time complextiy for this algorithm is, lets take the case of the item we are searching for being $x_n$, the last item of our array. If we were searching one item at a time, our time complexity function would be $O(n)$. 

The first time we divide the 


#### e.  What would the worst case time complexity be if we have 4000 entries instead of 2000?

```{r}
#| echo: false

log_2_2000<-round(log2(2000))
log_2_4000<-round(log2(4000))

```

The time complexity function for this algorithm is $O(\log_2(n))$. Thus we can say that the worst case time complexity if we have 4000 entries is found by $\log_2(4000) \approx$ `{r} log_2_4000`. This is in contrast to if we only had 2000 entries where the worst case time complexity would be $\log_2(2000)\approx$ `r log_2_2000`.

#### f. What do you think the average case time complexity is for binary search? Explain your reasoning.

I think that the average case time complexity for binary search is $\log_2(n)$. I will demonstrate this with a simulation. For this I will use `numbers.txt`, which has $1999$ elements, and perform a random sample of the indicies of `numbers.txt`, where $n=100000$ random indicies of `numbers.txt`. 

We hypothesize that the average time complexity for binary search is $\log_2(n)$, where $n$ is the number of items (indicies) of an array.

It is important to note that, $\log_2(2000)\approx$ `r log_2_2000`. 

To begin I will, using R, create a vector of random possible indicies of `numbers.txt` which has $1999\approx 2000$ indicies.

```{r , simulation to show average time complexity r part one}
#| echo: true

#### Some R code to establish the average time complexity of 
#### the binary search function. I am using R to sample random
#### indicies of numbers.txt, which I will then use in python to save the numbers of operations
#### it takes to find that specific value in numbers.txt, then I will create a distribution of
#### the number of operations in R and find the average number of operations. Then I will compare my 
#### emperical average from my simulation to my hypothesized value of $log_2(1999)\approx 11$.  


n<-100000                           #number of random indicies we want to samples
ind_numbers<-round(runif(n,0,1998)) #drawing random indicies from a discrete uniform(0,1998) dist.
                                    #rounding ensures integer values
View(ind_numbers)
write.table(ind_numbers, "clipboard", sep=",") 
```

Now that we have our vector of random integers we can move on to python.

```{python, simulation to show average time complexity python part one}
#| echo: true
#| eval: false

ind_data = r.ind_numbers #accessing the vector just created in R
type(ind_data[10]).__name__

operations_numbera = []

for value in ind_data:
 print(getattr(binary_search(item = value, data = numbers), 'operations')) 

```

### Problem 4

Evaluate the time complexity of the following code snippets. Evaluate line by line, create a time complexity function and then define its Big O value.

#### a. 

```{none}
function sum(arr){
  counter = 0

  for (i = 0; i < arr.length; i++) {
       counter += arr[i]
  }

     return counter
}
```

#### b. 

```{none}
function getXOR(arr1, arr2){

  arr3 = []

  for (i = 0; i < arr1.length; i++){
      let unique = True
      for (j = 0; j < arr2.length; j++ }{
        if(arr1[i] == arr2[j]) {unique = False;}
      }
      if (unique) {arr3.append(arr1[i]);}
    }
  }  
  for (i = 0; i < arr2.length; i++){
    let unique = True
    for (j = 0; j < arr1.length; j++ }{
      if(arr2[i] == arr1[j]) {unique = False;}
    }
    if (unique) {arr3.append(arr2[i]);}
  }
  return arr[3]
}
```