<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Eric Folsom">

<title>CS240 Midterm</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="CS240 Midterm - Eric Folsom_files/libs/clipboard/clipboard.min.js"></script>
<script src="CS240 Midterm - Eric Folsom_files/libs/quarto-html/quarto.js"></script>
<script src="CS240 Midterm - Eric Folsom_files/libs/quarto-html/popper.min.js"></script>
<script src="CS240 Midterm - Eric Folsom_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="CS240 Midterm - Eric Folsom_files/libs/quarto-html/anchor.min.js"></script>
<link href="CS240 Midterm - Eric Folsom_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="CS240 Midterm - Eric Folsom_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="CS240 Midterm - Eric Folsom_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="CS240 Midterm - Eric Folsom_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="CS240 Midterm - Eric Folsom_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">CS240 Midterm</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Eric Folsom </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="hanois-tower" class="level2">
<h2 class="anchored" data-anchor-id="hanois-tower">Hanoi’s Tower</h2>
<p>The Tower of Hanoi problem involves three rods and a number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks stacked in ascending order of size on one rod, the smallest at the top, making a cone.</p>
<p>The goal of the puzzle is to move the entire stack to another rod, obeying the following rules:</p>
<ol type="1">
<li>Only one disk can be moved at a time</li>
<li>Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.<br>
</li>
<li>No disk may be placed on top of a smaller disk.</li>
</ol>
<section id="the-following-resources-were-used-to-help-me-come-up-with-a-solution-to-the-problems-below" class="level4">
<h4 class="anchored" data-anchor-id="the-following-resources-were-used-to-help-me-come-up-with-a-solution-to-the-problems-below">The following resources were used to help me come up with a solution to the problems below:</h4>
<ul>
<li><a href="https://www.youtube.com/watch?v=rf6uf3jNjbo&amp;list=PLzj1WDt0HB4qDn6heuU8w6x0Hzd8EVX0q">YouTube video by Reducible</a> was incredibly helpful for my understanding of how the algorithm works and how the recursion for this problem functions. From about 16 minutes until 20 minutes there is en elegent animation which describes the recursion taking place in the algorithm.</li>
<li><a href="https://www.youtube.com/watch?v=PGuRmqpr6Oo">YouTube video by Numberphile</a> Was helpful for understanding the math behind the algorithm and to help me identify the pattern going on with moving disks which was helpful for my iterative approach. There was a harmonic version of the algorithm which helped ingrain the pattern in my mind.</li>
<li><a href="https://www.youtube.com/watch?v=2SUvWfNJSsM">Youtube video by 3blue1brown</a> Showed a solution to the problem using binary counting to solve the problem. This was very helpful for my iterative apprach, even though I did not use binary counting in my approach to solving the problem. Was also helpful for my reasoning on the recursive version. Once the recursion was explained in a “from the perspective of the bottom disk” manner everything pretty much clicked for me.</li>
</ul>
</section>
<section id="implement-a-solution-for-the-tower-of-hanoi-problem-using-recursion.-your-solution-should-move-the-disks-from-the-starting-peg-to-the-target-peg-using-the-auxiliary-peg." class="level4">
<h4 class="anchored" data-anchor-id="implement-a-solution-for-the-tower-of-hanoi-problem-using-recursion.-your-solution-should-move-the-disks-from-the-starting-peg-to-the-target-peg-using-the-auxiliary-peg.">1. Implement a solution for the Tower of Hanoi problem using recursion. Your solution should move the disks from the starting peg to the target peg using the auxiliary peg.</h4>
<p>Below is a diagram which shows a solution for the Tower of Hanoi problem when there are <span class="math inline">\(3\)</span> rods and <span class="math inline">\(n=3\)</span> disks:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./misc/HanoisTower3.png" class="img-fluid figure-img" style="width:75.0%"></p>
<figcaption class="figure-caption">Tower of Hanoi with 3 disks and 3 rods</figcaption>
</figure>
</div>
<p>We first start with all three disks stacked on Rod <span class="math inline">\(A\)</span>. Then procede with the following steps to end with all three disk stacked on rod <span class="math inline">\(C\)</span>:</p>
<ol type="1">
<li>Move the <span style="color:green;">Green</span> disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(C\)</span>.</li>
<li>Move the <span style="color:red;">Red</span> disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(B\)</span>.</li>
<li>Move the <span style="color:green;">Green</span> disk from rod <span class="math inline">\(C\)</span> to rod <span class="math inline">\(B\)</span>.</li>
<li>Move the <span style="color:blue;">Blue</span> disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(C\)</span>.</li>
<li>Move the <span style="color:green;">Green</span> disk from rod <span class="math inline">\(B\)</span> to rod <span class="math inline">\(A\)</span>.</li>
<li>Move the <span style="color:red;">Red</span> disk from rod <span class="math inline">\(B\)</span> to rod <span class="math inline">\(C\)</span>.</li>
<li>Move the <span style="color:green;">Green</span> disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(C\)</span>.</li>
</ol>
<p>These steps will move the stack of three disks from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(C\)</span> while following the established rules. We can break down the process a little more to understand what is going on and then build a recursive function from it. This solution to the Tower of Hanoi problem took <span class="math inline">\(7 = 2^3 -1\)</span> steps to solve.</p>
<p>Steps <span class="math inline">\(1\)</span> through <span class="math inline">\(3\)</span> involve us moving the <span style="color:green;">Green</span> and <span style="color:red;">Red</span> disks from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(B\)</span> using the auxilary rod <span class="math inline">\(C\)</span> to store the <span style="color:green;">Green</span> disk while we move the larger of the two disks to the middle rod. These steps involve moving the <span style="color:green;">Green</span> disk to rod <span class="math inline">\(C\)</span> then moving it from <span class="math inline">\(C\)</span> to rod <span class="math inline">\(B\)</span> once the larger disk is in place.</p>
<p>In step <span class="math inline">\(4\)</span> we are simply moving the <span style="color:blue;">Blue</span> disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(C\)</span>.</p>
<p>Now in steps <span class="math inline">\(5\)</span> through <span class="math inline">\(7\)</span> we are simply doing what we did in steps <span class="math inline">\(1\)</span> through <span class="math inline">\(3\)</span>, but instead of using rod <span class="math inline">\(C\)</span> as the auxillary rod, we are using rod <span class="math inline">\(A\)</span> as the auxillary rod to move the <span style="color:green;">Green</span> and <span style="color:red;">Red</span> disks from rod <span class="math inline">\(B\)</span> to rod <span class="math inline">\(C\)</span>.</p>
<p>Thinking recursively, step <span class="math inline">\(4\)</span> would represent our base case. We are simply moving a disk from one rod to another rod after we have removed all the rods that were on top of it.</p>
<p>The steps are as follows if we had <span class="math inline">\(n=1\)</span> disk or <span class="math inline">\(n=2\)</span> disks:</p>
<ul>
<li><p>If we only had <span class="math inline">\(n=1\)</span> disk (i.e.&nbsp;only the <span style="color:blue;">Blue</span> disk), this would take <span class="math inline">\(1\)</span> step to solve, move the <span style="color:blue;">Blue</span> disk to rod <span class="math inline">\(C\)</span> from rod <span class="math inline">\(A\)</span>.</p></li>
<li><p>If <span class="math inline">\(n=2\)</span> (i.e.&nbsp;only the <span style="color:red;">Red</span> and <span style="color:blue;">Blue</span> disks), the steps would be as follows</p>
<ol type="1">
<li>Move the <span style="color:red;">Red</span> disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(B\)</span>.</li>
<li>Move the <span style="color:blue;">Blue</span> disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(C\)</span>.</li>
<li>Move the <span style="color:red;">Red</span> disk from rod <span class="math inline">\(B\)</span> to rod <span class="math inline">\(C\)</span></li>
</ol></li>
</ul>
<p>Note that the base case (Move the <span style="color:blue;">Blue</span> disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(C\)</span>) always shows up in each of these scenarios.</p>
<p><strong>Formulating an Algorithm</strong></p>
<p>A good way to approach formulating an algorithm for this problem is look at things from the perspective of the disk that is on the bottom of a stack of disks (in the above diagram it is the <span style="color:blue;">Blue</span> disk). In order for that disk to move, we must first move the stack of disks that are on top of it from one rod to another rod.</p>
<p>Lets use the example of a <span class="math inline">\(3\)</span> disk variation of the problem. If we have a <span class="math inline">\(3\)</span> disk stack, to move the bottom disk, we have to move the top <span class="math inline">\(2\)</span> disks off of it. We can only move one disk at a time however, so to remove the stack of <span class="math inline">\(2\)</span> disks from the third disk, we have to move the singular disk first.</p>
<p>Once we have moved the singular disk, we can now go back to the starting stack of disks where we now have a stack of <span class="math inline">\(2\)</span> disks. From here we repeat the process, we have a stack of <span class="math inline">\(2\)</span> disks, to move the bottom disk, we have to move the singular disk above it.</p>
<p>Now there is only one valid rod for the top disk to go to, so we move it to that rod. Returning to the starting rod, there are no valid spots for us to move the disk to, since the remaing disk on the starting rod is assumed to be the biggest rod.</p>
<p>We can now look at the middle rod, from here, the only valid move is to move the disk back to the starting rod, but if we did that, we would have just undone the previous step. So let’s instead go to the last rod.</p>
<p>Our goal right now is to move the disk on the starting rod to an open rod. The only way to do this is to move the smallest disk, which is currently on the ending rod (if we moved the middle size disk we would have to put it on top of the largest disk). So we now have to move the disk that is on the ending rod onto the middle rod to open up space for our largest disk to be moved onto an open rod.</p>
<p>We now find ourselves in a familiar situation, we have a stack of <span class="math inline">\(2\)</span> disks, an open rod, and a rod that we want to move the stack of <span class="math inline">\(2\)</span> disks onto, which in this case is the rod containing the largest disk. From here since we have moved a stack of <span class="math inline">\(2\)</span> disks before, we move it again following the same process, just using different rods that we did before.</p>
<p>We already figured out what our base case is, moving a single disk from one rod to another available rod (a rod that is either empty or only has disks larger than the disk we are trying to move).</p>
<p>Next we need to think of the recursive step, which in this case is moving the <span class="math inline">\(n-1=3-1=2\)</span> remaining disks to another rod, using an auxilary rod.</p>
<p>This idea holds for <span class="math inline">\(n\)</span> rods. We would basically be breaking the problem down into smaller versions of this three disk version of the problem.</p>
<p>We can simplify all of the above to formulate an algorithm to solve this problem:</p>
<ol type="1">
<li>Move <span class="math inline">\(n-1\)</span> disks from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(B\)</span>. This uses rod <span class="math inline">\(C\)</span> as a “helper” rod.</li>
<li>Move the remaining disk from rod <span class="math inline">\(A\)</span> to rod <span class="math inline">\(C\)</span>.</li>
<li>Move the <span class="math inline">\(n-1\)</span> disks from rod <span class="math inline">\(B\)</span> to rod <span class="math inline">\(C\)</span>. This uses rod <span class="math inline">\(A\)</span> as a “helper” rod.</li>
</ol>
<p><strong>Code implementation of the algorithm</strong></p>
<p>Now lets try to implment this aproach to solving the problem using pseudocode:</p>
<pre class="{plain, hanoi tower pseudocode}"><code>def hanoistower(n, starting_rod = A, ending_rod = C, auxillary_rod = B)
    # base case only 1 disk to move
    if n == 1:
        move disk from starting rod to ending rod
    else:
        # recursively call the function to move the n-1 disks to the middle( auxilary) rod
        hanoistower(n-1, starting_rod = A, ending_rod = B, auxilary_rod = C)
        #some function to show the moving of the disks
        movedisk(start_rod, end_rod)
        # recursively call again to move the n-1 disks from the auxillary( middle) rod to the end rod
        hanoistower(n-1, starting_rod = B, ending_rod = C, auxilary_rod = A)</code></pre>
<p>Basically each time we recursively call the funciton, we are changing which rods we are moving the disks to so that when we eventually reach the base case, we are able to move the disk to the correct rod.</p>
<p>Now we can implement this funciton in python:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tower_of_hanoi(n, starting_rod, middle_rod, ending_rod): <span class="co"># specify the starting rods you want</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="co"># Base case, 1 disk on the rod, you can just move it to any open rod</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Disk </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>starting_rod<span class="sc">}</span><span class="ss"> -&gt; </span><span class="sc">{</span>ending_rod<span class="sc">}</span><span class="ss">"</span>) <span class="co"># show that we moved it</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="co"># recursive cases</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        tower_of_hanoi(n<span class="op">-</span><span class="dv">1</span>, starting_rod, ending_rod, middle_rod) <span class="co"># move the n-1 disks to the middle rod from starting rod</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Disk </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>starting_rod<span class="sc">}</span><span class="ss"> -&gt; </span><span class="sc">{</span>ending_rod<span class="sc">}</span><span class="ss">"</span>) <span class="co"># display the move</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        tower_of_hanoi(n<span class="op">-</span><span class="dv">1</span>, middle_rod, starting_rod, ending_rod) <span class="co"># move the n-1 disks from the middle rod to the ending rod</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can demonstrate this as follows:</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>tower_of_hanoi(<span class="dv">2</span>,<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Disk 1: A -&gt; B
Disk 2: A -&gt; C
Disk 1: B -&gt; C</code></pre>
</div>
</div>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>tower_of_hanoi(<span class="dv">3</span>,<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Disk 1: A -&gt; C
Disk 2: A -&gt; B
Disk 1: C -&gt; B
Disk 3: A -&gt; C
Disk 1: B -&gt; A
Disk 2: B -&gt; C
Disk 1: A -&gt; C</code></pre>
</div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>tower_of_hanoi(<span class="dv">4</span>,<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Disk 1: A -&gt; B
Disk 2: A -&gt; C
Disk 1: B -&gt; C
Disk 3: A -&gt; B
Disk 1: C -&gt; A
Disk 2: C -&gt; B
Disk 1: A -&gt; B
Disk 4: A -&gt; C
Disk 1: B -&gt; C
Disk 2: B -&gt; A
Disk 1: C -&gt; A
Disk 3: B -&gt; C
Disk 1: A -&gt; B
Disk 2: A -&gt; C
Disk 1: B -&gt; C</code></pre>
</div>
</div>
<p>I decided to go a bit further with this approach and implement a solution to the problem that uses stacks to store the state of the three rods, and then pops and pushes the disks to shift them between rods.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># function to move the top value of stack 1 to the top of stack 2</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> moveStack(stack1 <span class="op">=</span> stack(), stack2 <span class="op">=</span> stack()):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    temp <span class="op">=</span> stack1.pop()</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    stack2.push(temp)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="co"># tower of of hanoi recursive solution that works on the stacks </span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tower_of_hanoi_stacks(n, starting_rod, middle_rod, ending_rod): <span class="co"># specify the starting rods you want</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="co"># Base case</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        moveStack(starting_rod, ending_rod)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Starting Rod:</span><span class="ch">\n</span><span class="sc">{</span>starting_rod<span class="sc">}</span><span class="ch">\n</span><span class="ss">Auxilary Rod:</span><span class="ch">\n</span><span class="sc">{</span>middle_rod<span class="sc">}</span><span class="ch">\n</span><span class="ss">Ending Rod:</span><span class="ch">\n</span><span class="sc">{</span>ending_rod<span class="sc">}</span><span class="ch">\</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="ss">        </span><span class="ch">\n</span><span class="ss"> Moved disk </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="co"># if we are not on the last rod</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        tower_of_hanoi_stacks(n<span class="op">-</span><span class="dv">1</span>, starting_rod, ending_rod, middle_rod) <span class="co"># recursive call to move the n-1 disks to the middle rod using the ending rod as the axullary rod</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        moveStack(starting_rod, ending_rod) <span class="co"># move the current disk</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"Starting Rod:</span><span class="ch">\n</span><span class="sc">{</span>starting_rod<span class="sc">}</span><span class="ch">\n</span><span class="ss">Auxilary Rod:</span><span class="ch">\n</span><span class="sc">{</span>middle_rod<span class="sc">}</span><span class="ch">\n</span><span class="ss">Ending Rod:</span><span class="ch">\n</span><span class="sc">{</span>ending_rod<span class="sc">}</span><span class="ch">\</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="ss">        </span><span class="ch">\n</span><span class="ss"> Moved disk </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        tower_of_hanoi_stacks(n<span class="op">-</span><span class="dv">1</span>, middle_rod, starting_rod, ending_rod) <span class="co"># move the remaining n-1 disks to the ending rod using the starting rod as the auxillary rod</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co"># going to need to call the above:</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> TowerOfHanoi(n):<span class="co"># Tower of Hanoi with stacks and it will initialize the number of disks</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># n = number of disks</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">## initialize the starting, auxillary, and ending rods</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    starting_rod <span class="op">=</span> stack()</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    auxillary_rod <span class="op">=</span> stack()</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    ending_rod <span class="op">=</span> stack()</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># fill the starting rod</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>        starting_rod.push(i)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># display starting state</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Start:"</span>)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Starting Rod:</span><span class="ch">\n</span><span class="sc">{</span>starting_rod<span class="sc">}</span><span class="ch">\n</span><span class="ss">Auxillary Rod:</span><span class="ch">\n</span><span class="sc">{</span>auxillary_rod<span class="sc">}</span><span class="ch">\n</span><span class="ss">Ending Rod:</span><span class="ch">\n</span><span class="sc">{</span>ending_rod<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># now we can call the tower of hanoi function.</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    tower_of_hanoi_stacks(n, starting_rod, auxillary_rod, ending_rod)</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># show the final state</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"Ending:"</span>)</span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Starting Rod:</span><span class="ch">\n</span><span class="sc">{</span>starting_rod<span class="sc">}</span><span class="ch">\n</span><span class="ss">Auxillary Rod:</span><span class="ch">\n</span><span class="sc">{</span>auxillary_rod<span class="sc">}</span><span class="ch">\n</span><span class="ss">Ending Rod:</span><span class="ch">\n</span><span class="sc">{</span>ending_rod<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The output of the <code>TowerofHanoi()</code> function is as follows, I will be calling it on <span class="math inline">\(n=2\)</span> to save space:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>TowerOfHanoi(<span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Start:
Starting Rod:
| 1 |
| 2 |
-------
Auxillary Rod:

-------
Ending Rod:

-------
Starting Rod:
| 2 |
-------
Auxilary Rod:

-------
Ending Rod:
| 1 |
-------        
 Moved disk 1
Starting Rod:

-------
Auxilary Rod:
| 1 |
-------
Ending Rod:
| 2 |
-------        
 Moved disk 2
Starting Rod:

-------
Auxilary Rod:

-------
Ending Rod:
| 1 |
| 2 |
-------        
 Moved disk 1
Ending:
Starting Rod:

-------
Auxillary Rod:

-------
Ending Rod:
| 1 |
| 2 |
-------</code></pre>
</div>
</div>
</section>
<section id="implement-a-solution-for-the-tower-of-hanoi-problem-using-an-iterative-approach." class="level4">
<h4 class="anchored" data-anchor-id="implement-a-solution-for-the-tower-of-hanoi-problem-using-an-iterative-approach.">2. Implement a solution for the Tower of Hanoi problem using an iterative approach.</h4>
<p>To implement a solution for the Tower of Hanoir problem using an iterative approach, I will try to build upon my recursive approach.</p>
<p>Lets begin by analysing the pattern of the solutions generated by our recursive function. We know that the number of steps required to solve the problem is given by <span class="math inline">\(2^n-1\)</span>. We can use the number of steps required to solve the puzzle as our iterator.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>tower_of_hanoi(<span class="dv">3</span>, <span class="st">'A'</span>,<span class="st">'B'</span>,<span class="st">'C'</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">Output:</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">Step 1: Disk 1: A -&gt; C</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">Step 2: Disk 2: A -&gt; B</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">Step 3: Disk 1: C -&gt; B</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="co">Step 4: Disk 3: A -&gt; C</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">Step 5: Disk 1: B -&gt; A</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">Step 6: Disk 2: B -&gt; C</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">Step 7: Disk 1: A -&gt; C</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>tower_of_hanoi(<span class="dv">4</span>,<span class="st">"A"</span>,<span class="st">"B"</span>,<span class="st">"C"</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">Output:</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">Step 1: Disk 1: A -&gt; B</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co">Step 2: Disk 2: A -&gt; C</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">Step 3: Disk 1: B -&gt; C</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co">Step 4: Disk 3: A -&gt; B</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co">Step 5: Disk 1: C -&gt; A</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="co">Step 6: Disk 2: C -&gt; B</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">Step 7: Disk 1: A -&gt; B</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">Step 8: Disk 4: A -&gt; C</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">Step 9: Disk 1: B -&gt; C</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="co">Step 10: Disk 2: B -&gt; A</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="co">Step 11: Disk 1: C -&gt; A</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co">Step 12: Disk 3: B -&gt; C</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">Step 13: Disk 1: A -&gt; B</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">Step 14: Disk 2: A -&gt; C</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a><span class="co">Step 15: Disk 1: B -&gt; C</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="co">'''</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ignoring the actual number of the disk that is being moved, lets see if there is a pattern between what rods we are moving disks to and from. When <span class="math inline">\(n\)</span> is odd, the example where <span class="math inline">\(n=3\)</span>, we can break down the movements of the disks as such.</p>
<p>In steps <span class="math inline">\(1\)</span>, <span class="math inline">\(4\)</span> and <span class="math inline">\(7\)</span>, we are moving a disk from the starting rod to the ending rod.</p>
<p>In steps <span class="math inline">\(2\)</span> and <span class="math inline">\(5\)</span> we are moving a disk between the starting rod and the auxilary rod, swaping which direction we move the disks. In step <span class="math inline">\(2\)</span> we move the disk from the starting rod to the auxilary rod, and in step <span class="math inline">\(5\)</span> we move a disk from the auxillary rod to the starting rod.</p>
</section>
<section id="compare-the-time-and-space-complexity-of-both-the-recursive-and-iterative-solutions-and-explain-the-differences." class="level4">
<h4 class="anchored" data-anchor-id="compare-the-time-and-space-complexity-of-both-the-recursive-and-iterative-solutions-and-explain-the-differences.">3. Compare the time and space complexity of both the recursive and iterative solutions and explain the differences.</h4>
</section>
<section id="optional-but-extra-credit-create-a-graphical-user-interface-gui-that-demonstrates-the-steps-of-the-tower-of-hanoi-problem-as-the-disks-are-moved-from-the-starting-peg-to-the-target-peg.-the-gui-should-allow-the-user-to-specify-the-number-of-disks-and-the-speed-at-which-the-disks-move." class="level4">
<h4 class="anchored" data-anchor-id="optional-but-extra-credit-create-a-graphical-user-interface-gui-that-demonstrates-the-steps-of-the-tower-of-hanoi-problem-as-the-disks-are-moved-from-the-starting-peg-to-the-target-peg.-the-gui-should-allow-the-user-to-specify-the-number-of-disks-and-the-speed-at-which-the-disks-move.">4. (Optional, but extra credit) Create a graphical user interface (GUI) that demonstrates the steps of the Tower of Hanoi problem as the disks are moved from the starting peg to the target peg. The GUI should allow the user to specify the number of disks and the speed at which the disks move.</h4>
</section>
<section id="create-a-variation-of-the-tower-of-hanoi-problem-where-the-user-can-specify-more-than-three-pegs.-your-solution-should-still-move-all-the-disks-from-the-starting-peg-to-the-target-peg-while-adhering-to-the-rules-of-the-tower-of-hanoi-problem." class="level4">
<h4 class="anchored" data-anchor-id="create-a-variation-of-the-tower-of-hanoi-problem-where-the-user-can-specify-more-than-three-pegs.-your-solution-should-still-move-all-the-disks-from-the-starting-peg-to-the-target-peg-while-adhering-to-the-rules-of-the-tower-of-hanoi-problem.">5. Create a variation of the Tower of Hanoi problem where the user can specify more than three pegs. Your solution should still move all the disks from the starting peg to the target peg while adhering to the rules of the Tower of Hanoi problem.</h4>
</section>
<section id="optional-but-extra-credit-create-a-variation-of-the-tower-of-hanoi-problem-where-the-user-can-specify-the-number-of-disks-and-the-number-of-pegs.-your-solution-should-still-move-all-the-disks-from-the-starting-peg-to-the-target-peg-while-adhering-to-the-rules-of-the-tower-of-hanoi-problem." class="level4">
<h4 class="anchored" data-anchor-id="optional-but-extra-credit-create-a-variation-of-the-tower-of-hanoi-problem-where-the-user-can-specify-the-number-of-disks-and-the-number-of-pegs.-your-solution-should-still-move-all-the-disks-from-the-starting-peg-to-the-target-peg-while-adhering-to-the-rules-of-the-tower-of-hanoi-problem.">6. (Optional, but extra credit) Create a variation of the Tower of Hanoi problem where the user can specify the number of disks and the number of pegs. Your solution should still move all the disks from the starting peg to the target peg while adhering to the rules of the Tower of Hanoi problem.</h4>
</section>
</section>
<section id="spell-checker" class="level2">
<h2 class="anchored" data-anchor-id="spell-checker">Spell Checker</h2>
<p>Create a spell checker console program that uses a hash table data structure to store a dictionary of words. Your program should be able to:</p>
<ol type="1">
<li><p>Load a dictionary of words from a file into the hash table. You will need to create this yourself. Aim for 20 to 100 words.</p></li>
<li><p>Take a string of text as input and check each word in the text against the words in the dictionary stored in the hash table. Your program should identify any words that are not found in the dictionary and display them as “misspelled”.</p></li>
</ol>
<pre class="{plain}"><code>def Misspell(string):
    # split the string into each word, store it as a temp variable
    # created an empty array the length of the temp variable ( call it spellings)
    # for each word in the temp variable:
    #   run dictionary.get(word) and append the spellings array with the truth value if the word is in the dictionary or not
    # return the spellings array</code></pre>
<ol start="3" type="1">
<li><p>Implement a suggestion feature that suggests possible correct spellings for the misspelled words based on edit distance.</p></li>
<li><p>Implement a Levenshtein distance algorithm to compute the edit distance between two words.</p></li>
<li><p>Allow the user to add new words to the dictionary and update the hash table accordingly.</p></li>
<li><p>Handle collisions in the hash table using separate chaining.</p></li>
<li><p>Optimize the performance of your program in terms of time and space complexity.</p></li>
<li><p>Your program should be user-friendly and have a command-line interface.</p></li>
</ol>
</section>
<section id="code-library" class="level2">
<h2 class="anchored" data-anchor-id="code-library">Code Library</h2>
<p>My code library from this course can be found on my <a href="https://github.com/efolsom17/CS240-Data-Structure-and-Algorithm-Fundamentals/tree/main/cs240functions/src/cs240functions">GitHub</a>. It is a functioning python module that can be installed locally if the folder is downloaded (I am pretty sure at least). The file <code>'__init.py'</code> is the module that intializes the library and doesn’t contain any funcitons. I am continually updating it to enhance some of the funcitons when I notice a problem I encounter when trying to use these algorithms and data structures in later points in the quarter. Will contain more content by the end of the course.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>